*********************************************************
*AUTHOR: FABIO MALTONI                                  *
*DATE  : 11/8/2001                                      *
*NOTES : PROGRAM GENERATED BY WRITE_VIRTUALS.M          *
*********************************************************

      DOUBLE PRECISION FUNCTION  BBGHVIRT(I1,I2,I3)                                    
* ---------------------------------------------------------------------
* returns the interference between 1-loop amplitude and tree amplitude 
*                                                                      
* 2 Re(AMP_LO AMP_VIRT^* )                                             
*                                                                      
* for the process:                                                     
*          0 -> bbar1 b2 g3 h                                          
*                                                                      
* All momenta outgoing.                                                
* No averaging is performed for initial spins or colors.               
* Higgs-bottom and strong couplings are included.                      
* Virtual contributions calculated in DRED.                            
* UV divergences are subtracted here in the MSbar scheme.              
* IR divergences are present as epinv^2 and epinv terms.               
* If you want to use this subroutine for b bbar -> h g or h-> b bbar g 
* you only have to modifiy the sign of the born and of 'term'.         
* ---------------------------------------------------------------------

      IMPLICIT NONE
      INCLUDE 'constants.f'
      INCLUDE 'masses.f'
      INCLUDE 'epinv.f'
      INCLUDE 'prods.f'
      INCLUDE 'qcdcouple.f'
      INCLUDE 'ewcouple.f'
      INCLUDE 'susycoup.f'
      INCLUDE 'scale.f'

*     ARGUMENTS 
      INTEGER I1,I2,I3

*     EXTERNAL 
      DOUBLE PRECISION ddilog

*     LOCAL 
      DOUBLE PRECISION SN,TN,UN,MH2
      DOUBLE COMPLEX LNRAT
      DOUBLE PRECISION logm,logs,logt,logu,logs2,logt2,logu2
      DOUBLE PRECISION logmt2,logmu2,log1ms,log1mt,log1mu
      DOUBLE PRECISION dilogs,dilogt,dilogu
      DOUBLE PRECISION c0t,c0u,c0ms,c0mt,c0mu,d0st,d0su,d0tu
      DOUBLE PRECISION born,term

C     coupsq=susycoup**2*ghbb**2  => as in the Born function
      DOUBLE PRECISION coupsq

      coupsq=1d0   !change this


      mh2=s(i1,i2)+s(i1,i3)+s(i2,i3)
      sn =s(i1,i2)/mh2
      tn =s(i1,i3)/mh2
      un =s(i2,i3)/mh2

* compute the logs and the dilogs
* the following choice of the logs performs the trivial
* analytic continuation in any physical situation

               logm=dlog(musq/mh2)                            
               logs=dlog(abs(sn))                             
               logt=dlog(abs(tn))                             
               logu=dlog(abs(un))                             
               logs2=dreal(lnrat(sn,1d0)**2)                  
               logt2=dreal(lnrat(tn,1d0)**2)                  
               logu2=dreal(lnrat(un,1d0)**2)                  
c               logms2=dreal(lnrat(-sn,1d0)**2)                
               logmt2=dreal(lnrat(-tn,1d0)**2)                
               logmu2=dreal(lnrat(-un,1d0)**2)                
               log1ms=dlog(abs(1d0-sn))                       
               log1mt=dlog(abs(1d0-tn))                       
               log1mu=dlog(abs(1d0-un))                       
               if(sn.gt.1) then     ! b bbar -> g h           
                 dilogs=-ddilog(1d0/sn)+2d0*pisqo6-half*dlog(sn)**2  
                 dilogt=ddilog(tn)                            
                 dilogu=ddilog(un)                            
               elseif(tn.gt.1) then ! bbar g ->bbar g h       
                 dilogt=-ddilog(1d0/tn)+2d0*pisqo6-half*dlog(tn)**2  
                 dilogs=ddilog(sn)                            
                 dilogu=ddilog(un)                            
               elseif(un.gt.1) then ! b g ->b g h             
                 dilogu=-ddilog(1d0/un)+2d0*pisqo6-half*dlog(un)**2  
                 dilogs=ddilog(sn)                            
                 dilogt=ddilog(tn)                            
               else                 ! h-> b bbar g            
                 dilogu=ddilog(un)                            
                 dilogs=ddilog(sn)                            
                 dilogt=ddilog(tn)                            
               endif                                          

* compute the scalar integrals 
* the following integrals are dimensionless,   
* and are defined as in the tex notes, 
* and have a 1/(16 pi^2)*c_\Gamma understood in front 
* where c_\Gamma= (4 pi)^eps Gamma(1+eps) Gamma(1-eps)^2/Gamma(1-2eps)

c           c0s = 
c     .      epinv**2 + logm**2/2D0 + logms2/2D0 + 
c     .      epinv*(logm - logs) - logm*logs
           c0t = 
     .      epinv**2 + logm**2/2D0 + logmt2/2D0 + 
     .      epinv*(logm - logt) - logm*logt
           c0u = 
     .      epinv**2 + logm**2/2D0 + logmu2/2D0 + 
     .      epinv*(logm - logu) - logm*logu
           c0ms= epinv*logs + logm*logs - logs2/2D0
           c0mt= epinv*logt + logm*logt - logt2/2D0
           c0mu= epinv*logu + logm*logu - logu2/2D0
           d0su= 
     .        2d0*epinv**2 + 2d0*epinv*(logm - logs - logu) + 
     -  2d0*(-dilogs - dilogu + logm**2/2D0 - log1ms*logs + logs2/2D0 + 
     -     logm*(-logs - logu) - log1mu*logu + logs*logu + 
     -     logu2/2D0 - pisq/3D0)
           d0st= 
     .        2d0*epinv**2 + 2d0*epinv*(logm - logs - logt) + 
     -  2d0*(-dilogs - dilogt + logm**2/2D0 - log1ms*logs + logs2/2D0 + 
     -     logm*(-logs - logt) - log1mt*logt + logs*logt + 
     -     logt2/2D0 - pisq/3D0)
           d0tu= 
     .        2d0*epinv**2 + 2d0*epinv*(logm - logt - logu) + 
     -  2d0*(-dilogt - dilogu + logm**2/2D0 - log1mt*logt + logt2/2D0 + 
     -     logm*(-logt - logu) - log1mu*logu + logt*logu + 
     -     logu2/2D0 - pisq/3D0)

* the sign of born and term is valid only for g b->b h 

           born  =  -(16D0*(1+sn**2)/tn/un)*gsq*coupsq
           term  =  -(16D0*(1-sn)   /tn/un)*gsq*coupsq

* final result 

           BBGHVIRT=(CA-CF)*term+
     .        BORN*(CF*(-2d0*c0ms - c0mt - c0mu + c0t + c0u - d0st - 
     -       d0su) + (CA*(2d0*c0ms - 2d0*c0t - 2d0*c0u + d0st + d0su - 
     -         d0tu))/2D0)

           BBGHVIRT=ason2pi*BBGHVIRT

* UV renormalization of the strong coupling in DRED-MSbar 
* and finite renormalization to standard MSbar

           BBGHVIRT=BBGHVIRT+ason2pi*born*(-epinv*b0+CA/6d0)

* UV renormalization of the Yukawa coupling in DRED-MSbar
* and finite renormalization to standard MSbar

           BBGHVIRT=BBGHVIRT+ason2pi*born*(-epinv*3d0*CF-CF)

         END
